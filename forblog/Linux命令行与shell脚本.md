<!--
author: jimmy
head:
date: 2018-09-26
title: Linux命令行与shell脚本
tags: Linux
images: blog/img/2.jpg
category: Linux
status: publish
summary: Linux
-->
## Linux命令行与shell脚本

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=0} -->
<!-- code_chunk_output -->

* [Linux命令行与shell脚本](#linux命令行与shell脚本)
	* [1. Linux基础](#1-linux基础)
		* [1.1 文件系统](#11-文件系统)
		* [1.2 shell](#12-shell)
		* [1.3 Linux安全](#13-linux安全)
			* [1.3.1 /etc/passwd 文件](#131-etcpasswd-文件)
			* [1.3.2 /etc/shadow](#132-etcshadow)
			* [1.3.3 用户管理](#133-用户管理)
			* [1.3.4 组管理](#134-组管理)
			* [1.3.5 文件权限](#135-文件权限)
			* [1.3.6 改变安全性设置](#136-改变安全性设置)
	* [2.shell](#2shell)
		* [2.1 shell基础](#21-shell基础)
			* [2.1.1 重定向输入和输出](#211-重定向输入和输出)
			* [2.1.2 管道](#212-管道)
			* [2.1.3 退出脚本](#213-退出脚本)
		* [2.2 if](#22-if)
			* [2.2.1 数值比较](#221-数值比较)

<!-- /code_chunk_output -->

本文参考《Linux命令行与shell脚本编程大全》。
### 1. Linux基础
#### 1.1 文件系统
Linux内核支持通过不同类型的文件系统从硬盘中读写数据。除了自有的诸多文件系统外,Linux还支持从其他作系统(比如Microsoft Windows)采用的文件系统中读写数据。
Linux用来读写数据的标准文件系统如下表所示：

| 文件系统 | 描述 |
| :------------- | :------------- |
| ext | Linux扩展文件系统,最早的Linux文件系统 |
| ext2 | 第二扩展文件系统,在ext的基础上提供了更多的功能 |
| ext3 | 第三扩展文件系统,支持日志功能 |
| ext4 | 第四扩展文件系统,支持高级日志功能 |
| hpfs | OS/2高性能文件系统 |
| jfs | IBM日志文件系统 |
| iso9660 | ISO 9660文件系统(CD-ROM) |
| minix | MINIX文件系统 |
| msdos | 微软的FAT16 |
| ncp | Netware文件系统 |
| nfs | 网络文件系统 |
| ntfs | 支持Microsoft NT文件系统 |
| proc | 访问系统信息 |
| ReiserFS | 高级Linux文件系统,能提供更好的性能和硬盘恢复功能 |
| smb | 支持网络访问的Samba SMB文件系统 |
| sysv | 较早期的Unix文件系统 |
| ufs | BSD文件系统 |
| umsdos | 建立在msdos上的类Unix文件系统 |
| vfat | Windows 95文件系统(FAT32) |
| XFS | 高性能64位日志文件系统 |

在Linux文件系统中，通用的目录名用于表示一些常用的功能，下面是一些常见的Linux顶层虚拟目录名及内容：

| 目录 | 用途 |
| :------------- | :------------- |
| / | 虚拟目录的根目录。通常不会在这里存储文件 |
| /bin | 二进制目录,存放许多用户级的GNU工具 |
| /boot | 启动目录,存放启动文件 |
| /dev | 设备目录,Linux在这里创建设备节点 |
| /etc | 系统配置文件目录 |
| /home | 主目录,Linux在这里创建用户目录 |
| /lib | 库目录,存放系统和应用程序的库文件 |
| /media | 媒体目录,可移动媒体设备的常用挂载点 |
| /mnt | 挂载目录,另一个可移动媒体设备的常用挂载点 |
| /opt | 可选目录,常用于存放第三方软件包和数据文件 |
| /proc | 进程目录,存放现有硬件及当前进程的相关信息 |
| /root | root用户的主目录 |
| /sbin | 系统二进制目录,存放许多GNU管理员级工具 |
| /run | 运行目录,存放系统运作时的运行时数据 |
| /srv | 服务目录,存放本地服务的相关文件 |
| /sys | 系统目录,存放系统硬件信息的相关文件 |
| /tmp | 临时目录,可以在该目录中创建和删除临时工作文件 |
| /usr | 用户二进制目录,大量用户级的GNU工具和数据文件都存储在这里 |
| /var | 可变目录,用以存放经常变化的文件,比如日志文件 |

#### 1.2 shell
在Linux系统上,通常有好几种Linux shell可用。不同的shell有不同的特性,有些更利于创建脚本,有些则更利于管理进程。所有Linux发行版默认的shell都是bash shell。

| shell | 描述 |
| :------------- | :------------- |
| ash | 一种运行在内存受限环境中简单的轻量级shell,但与bash shell完全兼容 |
| korn | 一种与Bourne shell兼容的编程shell,但支持如关联数组和浮点运算等一些高级的编程特性 |
| tcsh | 一种将C语言中的一些元素引入到shell脚本中的shell |
| zsh | 一种结合了bash、tcsh和korn的特性,同时提供高级编程特性、共享历史文件和主题化提示符的高级shell |

#### 1.3 Linux安全
Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。用户对系统中各种对象的访问权限取决于他们登录系统时用的账户。
##### 1.3.1 /etc/passwd 文件
Linux系统使用/etc/passwd 来将用户的登录名匹配到对应的UID值。
> /etc/passwd 包含如下记录：
登录用户名
用户密码 （都为x，正式密码存储在另一个文件 /etc/shadow 中）
用户账户的UID(数字形式)
用户账户的组ID(GID)(数字形式)
用户账户的文本描述(称为备注字段)
用户HOME目录的位置
用户的默认shell

##### 1.3.2 /etc/shadow
/etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow 文件
> /etc/shadow 包含如下记录：
与/etc/passwd文件中的登录名字段对应的登录名
加密后的密码
自上次修改密码后过去的天数密码(自1970年1月1日开始计算)
多少天后才能更改密码
多少天后必须更改密码
密码过期前提前多少天提醒用户更改密码
密码过期后多少天禁用用户账户
用户账户被禁用的日期(用自1970年1月1日到当天的天数表示)
预留字段给将来使用

##### 1.3.3 用户管理
创建用户：useradd
删除用户：userdel
修改用户：
usermod，功能最强大，能修改/etc/passwd 大部分字段。
>-c 修改备注字段,
-e 修改过期日期
-g 修改默认的登录组)
-l 修改用户账户的登录名
-L 锁定账户,使用户无法登录
-p 修改账户的密码
-U 解除锁定,使用户能够登录

passwd和chpasswd(批量),修改密码
chsh(修改默认shell)、chfn(在/etc/passwd文件备注字段存储信息)、change(管理用户账户有效期)

##### 1.3.4 组管理
创建组：groupadd
组添加用户：usermod
修改组：groupmod

##### 1.3.5 文件权限
```
# ls -l 展示范例
-rwxrwxr-x 2 rich rich 4096 2010-09-03 15:12 test2
```
第一个字段是描述文件和目录权限的编码，之后有3组3字符的编码，分别定义了对象的3个安全级别：对象的拥有者，对象的组，系统的其他用户

文件类型符：

| 操作符 | 含义 |
| :------------- | :------------- |
| - | 代表文件 |
| d | 代表目录 |
| l | 代表链接 |
| c | 代表字符型设备 |
| b | 代表块设备 |
| n | 代表网络设备 |

文件访问权限符：
| r | 代表对象是可读的 |
| w | 代表对象是可写的 |
| x | 代表对象是可执行的 |
如果没有某种权限，在该权限位以 - 代替

上面范例说明登录名为rich的用户可以读取、写入以及执行这个文件(可以看作有全部权限)。类似地,rich组的成员也可以读取、写入和执行这个文件。然而不属于rich组的其他用户只能读取和执行这个文件: w 被单破折线取代了,说明这个安全级别没有写入权限。

权限符与权限码之间的转换，文件权限码为8进制,三组3字符转换为3位8进制数

| 权限 | 二进制值 | 八进制值 | 描述 |
| :------------- | :------------- | :------------- | :------------- |
| --- | 000 | 0 | 没有任何权限 |
| --x | 001 | 1 | 只有执行权限 |
| -w- | 010 | 2 | 只有写入权限 |
| -wx | 011 | 3 | 有写入和执行权限 |
| r-- | 100 | 4 | 只有读取权限 |
| r-x | 101 | 5 | 有读取和执行权限 |
| rw- | 110 | 6 | 有读取和写入权限 |
| rwx | 111 | 7 | 有全部权限 |

##### 1.3.6 改变安全性设置
改变权限：chmod
改变文件的属主：chown
改变文件的默认属组：chgrp

### 2.shell
#### 2.1 shell基础
shell命令分为内部命令和外部命令。
+ 外部命令
外部命令,有时候也被称为文件系统命令,是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。
```
# ps 就是个外部命令，可以使用which和type找到它
which ps #---> /bin/ps
type -a ps #---> ps is /bin/ps
```
当外部命令执行时，会创建一个子进程。

+ 内部命令
内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体,作为shell工具的组成部分存在。
```
type cd #--->cd is a shell builtin
```

在涉及环境变量名时,什么时候该使用 $ ,什么时候不该使用 $ ,实在让人摸不着头脑。
记住一点就行了:如果要用到变量,使用 $ ;如果要操作变量,不使用 $ 。

##### 2.1.1 重定向输入和输出
+ 输出重定向
( \> ) 将命令的输出发送到一个文件中，如果文件已存在，使用新的文件数据覆盖已有文件。
( \>\> ) 将命令输出追加到已有文件中。
( \< ) 将文件内容重定向到命令
( \<\< ) 内联输入重定向，直接将后面内容重定向到命令

##### 2.1.2 管道
将一条命令的输出重定向为另一条命令的输入，这个过程称为管道连接。
( | ) 将前一条命令的输出重定向到另一条命令中
Linux系统实际上会同时运行这两条命令，在系统内部将它们连接起来，在第一条命令产生输出同时，输出会立刻送给第二条命令，数据传输不会用到中间文件或缓冲区。

##### 2.1.3 退出脚本
( exit ) 使用该命令返回退出状态码

#### 2.2 结果化命令
#### 2.2.1 if　命令
```
if command
then
    commands
else
    commands
fi
```
if 语句会运行后面那个命令，如果该命令的退出状态码是0（执行成功），then部分命令才会执行，否则执行else部分命令；fi表示 if-then 语句到此结束。

##### 2.2.1.1 数值比较
使用test命令判断条件是否成立，如果成立test返回0；也可以使用方括号,第一个方括号之后和第二个方括号之前必须加上一个空格
```
if test command
then
    commands
fi
或者
if [ command ]
then
    commands
fi
```

数值比较命令如下

| 比较 | 描述 |
| :------------- | :------------- |
| n1 -eq n2 | 检查 n1 是否与 n2 相等 |
| n1 -ge n2 | 检查 n1 是否大于或等于 n2 |
| n1 -gt n2 | 检查 n1 是否大于 n2 |
| n1 -le n2 | 检查 n1 是否小于或等于 n2 |
| n1 -lt n2 | 检查 n1 是否小于 n2 |
| n1 -ne n2 | 检查 n1 是否不等于 n2 |

字符串比较（大于号、小于号需要使用 \\ 转义
> 在该比较中大写字母比小写字母小，而在sort中正好相反

| 比较 | 描述 |
| :------------- | :------------- |
| str1 = str2 | 检查 str1 是否和 str2 相同 |
| str1 != str2 | 检查 str1 是否和 str2 不同 |
| str1 < str2 | 检查 str1 是否比 str2 小 |
| -n str1 | 检查 str1 的长度是否非0 |
| -z str1 | 检查 str1 的长度是否为0 |

文件比较

| 比较 | 描述 |
| :------------- | :------------- |
| -d file | 检查 file 是否存在并是一个目录 |
| -e file | 检查 file 是否存在 |
| -f file | 检查 file 是否存在并是一个文件 |
| -r file | 检查 file 是否存在并可读 |
| -s file | 检查 file 是否存在并非空 |
| -w file | 检查 file 是否存在并可写 |
| -x file | 检查 file 是否存在并可执行 |
| -O file | 检查 file 是否存在并属当前用户所有 |
| -G file | 检查 file 是否存在并且默认组与当前用户相同 |
| file1 -nt file2 | 检查 file1 是否比 file2 新 |
| file1 -ot file2 | 检查 file1 是否比 file2 旧 |

##### 2.2.1.2 if高级特性
+ 双括号
```
((expression))
```
expression 可以是任意数学赋值或比较表达式
+ 双方括号
```
[[expression]]
```
双括号为字符串比较高级特性，不仅可以使用标准字符串比较，还可以匹配字符串。

####　2.2.2 case 命令
case 命令采用列表格式来检查单个变量的多个值。
```
case variable in
pattern1 | pattern2) commands1;;
pattern3) commands2;;
*) default commands;;
esac

#!/bin/bash
# using the case command
#
case $USER in
rich | barbara)
echo "Welcome, $USER"
echo "Please enjoy your visit";;
testing)
echo "Special testing account";;
jessica)
echo "Do not forget to log off when you're done";;
*)
echo "Sorry, you are not allowed here";;
esac
```

#### 2.2.3 for 命令
```
for var in list
do
    commands
done
```
for 默认字段分隔符为 **空格** **制表符** **换行符**，修改分隔符，需修改IFS值
```
IFS=$','
```
如果要指定多个 IFS 字符,只要将它们在赋值行串起来就行。

#### 2.2.4 while 与 until 命令
```
while test command
do
    other commands
done
```
while可以使用多个测试条件，但只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。

```
until test commands
do
    other commands
done
```

可以在done 之后将循环结果重定向

#### 2.2.5 控制循环
+ break 跳出循环
break n 可以使用n指定跳出的循环层级
+ continue 中止某次循环

#### 2.3 用户输入
##### 2.3.1 命令行参数
命令行参数命令如下：

|  | 功能 |
| :------------- | :------------- |
| $0 | 获取脚本名 |
| $1 | 获取命令行第一个参数（1-9），每个参数以空格分开 |
| $#  | 获取命令行参数个数 |
| $* | 获取命令所有参数，当成一个单词 |
| $@ | 获取命令行所有参数，当成多个单词 |
| shift | 移动命令行参数，跳过不需要参数 |
| getopt | 格式化命令行参数 |

##### 2.3.2 用户输入参数
read命令接受输入放入变量，如果未指定变量，放入 REPLY 变量中
1. 使用 echo -n 接收
```
echo -n "Enter your name:"
read name
```
2. read -p 直接接受
```
read -p "Enter your name:" name
```

read -t 时间 : 指定超时时间
read -n 长度 ： 指定长度
read -s : 隐藏输入信息，如密码等
文件读取：对文件使用 cat 命令,将结果通过管道直接传给含有 read 命令的 while 命令
```
cat test | while read line
do
    commands
done
```
