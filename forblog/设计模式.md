# 设计模式


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=0} -->
<!-- code_chunk_output -->

* [设计模式](#设计模式)
		* [一、设计模式的分类](#一-设计模式的分类)
		* [二、设计模式的六大原则](#二-设计模式的六大原则)
		* [三、java中的设计模式](#三-java中的设计模式)
			* [3.1 单例模式](#31-单例模式)
			* [3.2 工厂模式](#32-工厂模式)
				* [3.2.1 工厂模式](#321-工厂模式)
				* [3.2.2 抽象工厂模式](#322-抽象工厂模式)
			* [3.3 代理模式](#33-代理模式)
			* [3.4 策略模式](#34-策略模式)
			* [3.5 适配器模式](#35-适配器模式)
			* [3.6 观察者模式](#36-观察者模式)

<!-- /code_chunk_output -->
**面向接口编程而不是面向实现编程
优先使用组合而不是继承
发现变化并且封装变化**
设计模式根本原因是为了代码服用，提高可维护性

### 一、设计模式的分类
总体来说设计模式分为三大类：

+ 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

+ 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

+ 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

+ 其实还有两类：并发型模式和线程池模式。

### 二、设计模式的六大原则
1. 开闭原则
对扩展开放，对修改关闭。为了程序的扩展性好，易于维护与还是升级

2. 里氏代换原则
面向对象设计基本原则之一，表示为任何子类均可替代父类

3. 依赖倒转原则
这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。

4. 接口隔离原则
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

5. 迪米特法则（最少知道原则）
为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

6. 合成复用原则
原则是尽量使用合成/聚合的方式，而不是使用继承。
> 类之间关系
>种类： Generalization(泛化)，Dependency(依赖关系)、Association(关联关系)、Aggregation(聚合关系)、Composition(合成关系)。
> 其中Aggregation(聚合关系)、Composition(合成关系)属于Association(关联关系)，是特殊的Association关联关系。
> 1. 泛化：继承或实现关系（is a）
> 2. 关联：类之间的连接，一个类知道另一个类的属性和方法。（has a）
> 3. 聚合：是关联关系一种，是强的关联关系，聚合关系是整体和个体的关系
> 4. 组合：是关联关系一种，是比聚合关系强的关系。它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。Composition(组合关系)是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一致。如果A由B组成，表现为A包含有B的全局对象，并且B对象在A创建的时刻创建。
> 5. 依赖：表现为函数中的参数(use a)。是类与类之间的连接，表示一个类依赖于另一个类的定义，其中一个类的变化将影响另外一个类。


### 三、java中的设计模式
先学习几种常见的设计模式
#### 3.1 单例模式
该类负责创建自己的对象，同时确保只有单个对象被创建。
在考虑多线程时，引入双重检查锁定。具体见
#### 3.2 工厂模式
凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。
##### 3.2.1 工厂模式
一般使用静态工厂模式，将多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。
```
public class SendFactory {  

    public static Sender produceMail(){  
        return new MailSender();  
    }  

    public static Sender produceSms(){  
        return new SmsSender();  
    }  
}  
```

```
public class FactoryTest {  

    public static void main(String[] args) {      
        Sender sender = SendFactory.produceMail();  
        sender.Send();  
    }  
}  

```

##### 3.2.2 抽象工厂模式
工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。

#### 3.3 代理模式

#### 3.4 策略模式
#### 3.5 适配器模式
#### 3.6 观察者模式
当一个对象发生变化，其他依赖该对象的对象都收到通知，并随着变化。

参考：
[java开发的23种设计模式](https://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html)
[java双重检查锁定](http://blog.csdn.net/kufeiyun/article/details/6166673)
[Java单例对象同步问题探讨](https://www.ibm.com/developerworks/cn/java/l-singleton/)
