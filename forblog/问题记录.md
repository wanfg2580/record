
### InputStream、OutputStream 使用了什么设计模式
装饰器模式与适配器模式

### Stream Buffer区别
所有的io设备都可以被分为流设备和块设备,块设备指的是把数据打包成块进行传输,传输基本单位为块,传输过程中需要缓冲区(buffer)支持,当然,读写也是以块作为基本单位.对于流设备(也称为字符设备),传输过程是以字节流形式进行的,这样的设备是不需要缓冲机制的.
流io一般速度低于块io，并不是绝对，拿水龙头来比喻：流就像水龙头滴水，每次只有一滴；块就像水龙头往水壶放水，放满之后对一整个水壶的水进行操作。
1. 针对一段固定大小的数据 n byte，流是对每一个字节进行读取，每次读取调用一次系统函数，所以是需要n次调用。而块则是一次一块，假设块大小为b因此系统函数调用的次数为[n/b]+1，特别是当数据比较大时，效率更高
2. 流io为阻塞模式,而块io支持非阻塞(不考虑消息轮询);多线程情况下，把文件看成一个块数组的话,我们可以多线程对不同的块进行操作，比如thread1 操作块1，thread2操作块2...而对于流，由于流只能顺序读取，因此基本没有优势。
3. 在数据的实时性要求比较严的情况下，流就很方便了，每次写入一个字节系统就能立即将数据传输给程序，而块则是等到缓冲区满或者flush之后才进行处理
4. 处理数据方面，我们可以非常方便的节为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分。而对于一整块的数据处理起来相对就麻烦了。
5. 占用内存：由于流面向字节，一次只需要少量内存即可，而面向快由于需要缓冲区的协助，因此内存的大小与块的大小以及数量直接相关，即使块中数据并没有填满，仍然需要占用这么多内存。

### 带返回多线程 callable 与runnable
相同点：
两者都可用来编写多线程程序；
两者都需要调用Thread.start()启动线程；

不同点：
两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；
Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；

注意点：
Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！

### java 迭代器移除元素
在遍历数组和集合时，不能用foreach边迭代边删除，必须显示写出迭代器对象，否则会报错java.util.ConcurrentModificationException
在使用Iterator的时候，迭代器会新建一个线程，把原来的线程中的对象重新拷贝一份，在进行删除，修改等操作时，原来的线程只负责迭代，而Iterator负责迭代和删除操作，Iterator每次迭代都会检查迭代器里的对象和原线程中的对象个数是否一致，不一致则抛出：ConcurrentModificationException。
解决办法：不使用集合的remove方法，使用iterrator的remove。

### map 迭代使用什么
1. 二次取值
2. Iterator迭代器循环Map.entrySet().iterator()
3. Map.Entry 遍历---->效率高
4. Map.values()取值

### java i++ 是原子操作吗、volatile原理
1. 为什么会产生错误的数据？
多线程引起的，因为对于多线程同时操作一个整型变量在大并发操作的情况下无法做到同步，而Atomic提供了很多针对此类线程安全问题的解决方案，因此解决了同时读写操作的问题。
2. 为什么会造成同步问题？
Java多线程在对变量进行操作的时候，实际上是每个线程会单独分配一个针对i值的拷贝(独立内存区域)，但是申明的i值确是在主内存区域中，当对i值修改完毕后，线程会将自己内存区域块中的i值拷贝到主内存区域中，因此有可能每个线程拿到的i值是不一样的，从而出现了同步问题。
3. 为什么使用volatile修饰integer变量后，还是不行？
因为volatile仅仅只是解决了存储的问题，即i值只是保留在了一个内存区域中，但是i++这个操作，涉及到获取i值、修改i值、存储i值(i=i+1)，这里的volatile只是解决了存储i值得问题，至于获取和修改i值，确是没有做到同步。
4. 既然不能做到同步，那为什么还要用volatile这种修饰符？
主要的一个原因是方便，因为只需添加一个修饰符即可，而无需做对象加锁、解锁这么麻烦的操作。但是本人不推荐使用这种机制，因为比较容易出问题(脏数据)，而且也保证不了同步。
5. 那到底如何解决这样的问题？
第一种：采用同步synchronized解决，这样虽然解决了问题，但是也降低了系统的性能。
第二种：采用原子性数据Atomic变量，这是从JDK1.5开始才存在的针对原子性的解决方案，这种方案也是目前比较好的解决方案了。
6. Atomic的实现基本原理？
首先Atomic中的变量是申明为了volatile变量的，这样就保证的变量的存储和读取是一致的，都是来自同一个内存块，然后Atomic提供了getAndIncrement方法，该方法对变量的++操作进行了封装，并提供了compareAndSet方法，来完成对单个变量的加锁和解锁操作，方法中用到了一个UnSafe的对象，现在还不知道这个UnSafe的工作原理(似乎没有公开源代码)。Atomic虽然解决了同步的问题，但是性能上面还是会有所损失，不过影响不大，网上有针对这方面的测试，大概50million的操作对比是250ms : 850ms，对于大部分的高性能应用，应该还是够的了。

### threshold 详解
### java锁
### redis 数据结构
### 线程池中线程处于什么线程什么阶段
### dubbo中线程池
### GC
### 一致性hash算法
### 循环数组
### blockingQueue
